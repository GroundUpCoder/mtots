r"""
Roughly based on the JavaScript glMatrix (https://glmatrix.net/)

4x4 matrices are represented as ByteArray containing 16 32-bit floating
point numbers.
"""
import bytearray

# 4x4 Matrix
# _arr stores the components in column-major order
class Mat4:
  def __init__(values=nil):
    this._arr = [0] * 16

    if values == nil:
      this._arr[0]  = 1
      this._arr[5]  = 1
      this._arr[10] = 1
      this._arr[15] = 1
    else:
      this._arr = list(values)
      if len(this._arr) != 16:
        raise 'Expected 16 values but got %s' % [len(this._arr)]

  def setIdentity():
    final arr = this._arr
    for i in range(16):
      arr[i] = 0
    arr[0]  = 1
    arr[5]  = 1
    arr[10] = 1
    arr[15] = 1

  def toByteArray():
    return bytearray.fromF32(this._arr)

  def setByteArray(ba):
    for i in range(16):
      ba.f32(4 * i, this._arr[i])

  def setPerspective(fovy, aspect, near, far=nil):
    r"""
    Sets this to a perspective projection matrix with the given bounds.
    The near/far clip planes correspond to a normalized device coordinate
      Z range of [-1, 1], which matches WebGL/OpenGL's clip volume.
    Passing nil for far will generate an infinite projection matrix.

      fovy Number: Vertical field of view in radians
      aspect Number: Aspect ratio. Typically viewport width/height
      near Number: Near bound of the frustum
      far Number: Far bound of the frustum, can be null or INFINITY
    """
    final arr = this._arr
    for i in range(16):
      arr[i] = 0
    final f = 1.0 / tan(fovy / 2)
    arr[0] = f / aspect
    arr[5] = f
    arr[11] = -1
    if far != nil and far != INFINITY:
      final nf = 1 / (near - far)
      arr[10] = (far + near) * nf
      arr[14] = 2 * far * near * nf
    else:
      arr[10] = -1
      arr[14] = -2 * near

  def setTranslate(a, v):
    r"""
    Translate a Mat4 by the given vector
      a Mat4: the matrix to translate
      v Vec3: the vector to translate by
    """
    a = a._arr
    final out = this._arr
    final x = v[0]
    final y = v[1]
    final z = v[2]

    if a is out:
      out[12] = a[0] * x + a[4] * y + a[8] * z + a[12]
      out[13] = a[1] * x + a[5] * y + a[9] * z + a[13]
      out[14] = a[2] * x + a[6] * y + a[10] * z + a[14]
      out[15] = a[3] * x + a[7] * y + a[11] * z + a[15]
    else:
      final a00 = a[0]
      final a01 = a[1]
      final a02 = a[2]
      final a03 = a[3]
      final a10 = a[4]
      final a11 = a[5]
      final a12 = a[6]
      final a13 = a[7]
      final a20 = a[8]
      final a21 = a[9]
      final a22 = a[10]
      final a23 = a[11]

      out[0] = a00
      out[1] = a01
      out[2] = a02
      out[3] = a03
      out[4] = a10
      out[5] = a11
      out[6] = a12
      out[7] = a13
      out[8] = a20
      out[9] = a21
      out[10] = a22
      out[11] = a23

      out[12] = a00 * x + a10 * y + a20 * z + a[12]
      out[13] = a01 * x + a11 * y + a21 * z + a[13]
      out[14] = a02 * x + a12 * y + a22 * z + a[14]
      out[15] = a03 * x + a13 * y + a23 * z + a[15]
