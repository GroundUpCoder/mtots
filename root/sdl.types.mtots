r"""Bindings for the SDL library
"""

final WINDOW_FULLSCREEN = 0
final WINDOW_OPENGL = 0
final WINDOW_SHOWN = 0
final WINDOW_HIDDEN = 0
final WINDOW_BORDERLESS = 0
final WINDOW_RESIZABLE = 0
final WINDOW_MINIMIZED = 0
final WINDOW_MAXIMIZED = 0
final WINDOW_MOUSE_GRABBED = 0
final WINDOW_INPUT_FOCUS = 0
final WINDOW_MOUSE_FOCUS = 0
final WINDOW_FULLSCREEN_DESKTOP = 0
final WINDOW_FOREIGN = 0
final WINDOW_ALLOW_HIGHDPI = 0
final WINDOW_MOUSE_CAPTURE = 0
final WINDOW_ALWAYS_ON_TOP = 0
final WINDOW_SKIP_TASKBAR = 0
final WINDOW_UTILITY = 0
final WINDOW_TOOLTIP = 0
final WINDOW_POPUP_MENU = 0
final WINDOW_KEYBOARD_GRABBED = 0
final WINDOW_VULKAN = 0
final WINDOW_METAL = 0
final WINDOW_INPUT_GRABBED = 0
final WINDOWPOS_CENTERED = 0
final WINDOWPOS_UNDEFINED = 0
final INIT_TIMER = 0
final INIT_AUDIO = 0
final INIT_VIDEO = 0
final INIT_JOYSTICK = 0
final INIT_HAPTIC = 0
final INIT_GAMECONTROLLER = 0
final INIT_EVENTS = 0
final INIT_EVERYTHING = 0
final AUDIO_TRACK_COUNT = 0
final AUDIO_S8 = 0
final AUDIO_U8 = 0
final AUDIO_S16LSB = 0
final AUDIO_S16MSB = 0
final AUDIO_S16SYS = 0
final AUDIO_S16 = 0
final AUDIO_U16LSB = 0
final AUDIO_U16MSB = 0
final AUDIO_U16SYS = 0
final AUDIO_U16 = 0
final AUDIO_S32LSB = 0
final AUDIO_S32MSB = 0
final AUDIO_S32SYS = 0
final AUDIO_S32 = 0
final AUDIO_F32LSB = 0
final AUDIO_F32MSB = 0
final AUDIO_F32SYS = 0
final AUDIO_F32 = 0
final WAVE_FORM_SINE = 0
final WAVE_FORM_SAWTOOTH = 0
final WAVE_FORM_SQUARE = 0
final WAVE_FORM_TRIANGLE = 0
final FINGERMOTION = 0
final FINGERDOWN = 0
final FINGERUP = 0
final KEYDOWN = 0
final KEYUP = 0
final MOUSEMOTION = 0
final MOUSEBUTTONDOWN = 0
final MOUSEBUTTONUP = 0
final MOUSEWHEEL = 0
final QUIT = 0

final scancode dict[string, int] = {}
final key dict[string, int] = {}


class Event:
  "Wrapper around SDL's native Event struct"

  final type int
  final key int
  final repeat bool


class Rect:
  var x int
  var y int
  var w int
  var h int

  def __init__(x, y, width, heigth):
    pass


class Window:
  "Window comments"


def createWindow(title string, x int, y int, width int, height int, flags int) Window:
  r"""
  Create a window
  """


class Renderer:
  def present() nil:
    r"""
    Update the screen with any rendering performed since the previous call.
    SDL's rendering functions operate on a backbuffer; that is, calling a
    rendering function such as SDL_RenderDrawLine() does not directly put
    a line on the screen, but rather updates the backbuffer.
    As such, you compose your entire scene and *present* the composed
    backbuffer to the screen as a complete picture.
    Therefore, when using SDL's rendering API, one does all drawing intended
    for the frame, and then calls this function once per frame to present
    the final drawing to the user. The backbuffer should be considered
    invalidated after each present; do not assume that previous contents
    will exist between frames. You are strongly encouraged to call
    SDL_RenderClear() to initialize the backbuffer before starting each
    new frame's drawing, even if you plan to overwrite every pixel.

    Parameters:
    * renderer - the rendering context
    """

  def setDrawColor(r int, g int, b int, a int) int:
    r"""
    ## SDL_SetRenderDrawColor
    Set the color used for drawing operations (Rect, Line and Clear).
    Set the color for drawing or filling rectangles, lines, and points,
    and for SDL_RenderClear().

    Parameters:
    * r - the red value used to draw on the rendering target
    * g - the green value used to draw on the rendering target
    * b - the blue value used to draw on the rendering target
    * a - the alpha value used to draw on the rendering target;
        usually `SDL_ALPHA_OPAQUE` (255).
        Use SDL_SetRenderDrawBlendMode to specify how the alpha channel is used

    Returns:
    0 on success or a negative error code on failure; call SDL_GetError()
    for more information.
    """

  def fillRect(rect Rect) nil:
    r"""
    ## SDL_RenderFillRect
    Fill a rectangle on the current rendering target with the drawing color.
    The current drawing color is set by SDL_SetRenderDrawColor(),
    and the color's alpha value is ignored unless blending is enabled with the
    appropriate call to SDL_SetRenderDrawBlendMode().

    Parameters:
    * rect - the SDL_Rect structure representing the rectangle to fill,
      or NULL for the entire rendering target

    Returns:
    0 on success or a negative error code on failure; call SDL_GetError()
    for more information.
    """


def createRenderer(window Window, index int, flags int) Renderer:
  r"""
  Create a 2D rendering context for a window.

  Parameters:
  * window - the window where rendering is displayed
  * index - the index of the rendering driver to initialize, or -1 to
    initialize the first one supporting the requested flags
  * flags - 0, or one or more SDL_RendererFlags OR'd together

  Returns:
  a valid rendering context or NULL if there was an error; call
  SDL_GetError() for more information.
  """


def getTicks() float:
  r"""
  The `getTicks` function does not actually use SDL_GetTicks().
  Instead it is `SDL_GetPerformanceCounter()/SDL_GetPerformanceFrequency() * 1000`
  """


class KeyboardState:
  pass


def getKeyboardState() KeyboardState:
  pass


def init(flags int) nil:
  r"""
  ## SDL_Init
  Initialize the SDL library.

  SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the
  two may be used interchangeably. Though for readability of your code
  SDL_InitSubSystem() might be preferred.

  The file I/O (for example: SDL_RWFromFile) and threading (SDL_CreateThread)
  subsystems are initialized by default. Message boxes
  (SDL_ShowSimpleMessageBox) also attempt to work without initializing the
  video subsystem, in hopes of being useful in showing an error dialog when
  SDL_Init fails. You must specifically initialize other subsystems if you
  use them in your application.

  Logging (such as SDL_Log) works without initialization, too.

  `flags` may be any of the following OR'd together:

  - `SDL_INIT_TIMER`: timer subsystem
  - `SDL_INIT_AUDIO`: audio subsystem
  - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events
    subsystem
  - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the
    events subsystem
  - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem
  - `SDL_INIT_GAMECONTROLLER`: controller subsystem; automatically
    initializes the joystick subsystem
  - `SDL_INIT_EVENTS`: events subsystem
  - `SDL_INIT_EVERYTHING`: all of the above subsystems
  - `SDL_INIT_NOPARACHUTE`: compatibility; this flag is ignored

  Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()
  for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or
  call SDL_Quit() to force shutdown). If a subsystem is already loaded then
  this call will increase the ref-count and return.

  - \param flags subsystem initialization flags
  \returns 0 on success or a negative error code on failure; call
           SDL_GetError() for more information.

  \since This function is available since SDL 2.0.0.
  """


def quit() nil:
  r"""
  Clean up all initialized subsystems.

  You should call this function even if you have already shutdown each
  initialized subsystem with SDL_QuitSubSystem(). It is safe to call this
  function even in the case of errors in initialization.

  If you start a subsystem using a call to that subsystem's init function
  (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),
  then you must use that subsystem's quit function (SDL_VideoQuit()) to shut
  it down before calling SDL_Quit(). But generally, you should not be using
  those functions directly anyhow; use SDL_Init() instead.

  You can use this function with atexit() to ensure that it is run when your
  application is shutdown, but it is not wise to do this from a library or
  other dynamically loaded code.

  \since This function is available since SDL 2.0.0.
  """

def delay(ms int) nil:
  r"""
  NOTE: on emscripten, `emscripten_sleep` is used instead of `SDL_delay`.

  ## SDL_delay

  Wait a specified number of milliseconds before returning.

  This function waits a specified number of milliseconds before returning. It
  waits at least the specified time, but possibly longer due to OS
  scheduling.

  - \param ms the number of milliseconds to delay

  \since This function is available since SDL 2.0.0.
  """


def pollEvent(event Event) bool:
  r"""
  ## SDL_PollEvent

  Poll for currently pending events.

  If `event` is not NULL, the next event is removed from the queue and stored
  in the SDL_Event structure pointed to by `event`. The 1 returned refers to
  this event, immediately stored in the SDL Event structure -- not an event
  to follow.

  If `event` is NULL, it simply returns 1 if there is an event in the queue,
  but will not remove it from the queue.

  As this function may implicitly call SDL_PumpEvents(), you can only call
  this function in the thread that set the video mode.

  SDL_PollEvent() is the favored way of receiving system events since it can
  be done from the main loop and does not suspend the main loop while waiting
  on an event to be posted.

  The common practice is to fully process the event queue once every frame,
  usually as a first step before updating the game's state:

  ```c
  while (game_is_still_running) {
      SDL_Event event;
      while (SDL_PollEvent(&event)) {  // poll until all events are handled!
          // decide what to do with this event.
      }

      // update game state, draw the current frame
  }
  ```

  \param event the SDL_Event structure to be filled with the next event from
               the queue, or NULL
  \returns 1 if there is a pending event or 0 if there are none available.

  \since This function is available since SDL 2.0.0.
  """


class AudioDevice:
  r"""
  Wrapper around SDL_AudioDeviceID

  ## typedef Uint32 SDL_AudioDeviceID

  SDL Audio Device IDs.

  A successful call to SDL_OpenAudio() is always device id 1, and legacy
  SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls
  always returns devices >= 2 on success. The legacy calls are good both
  for backwards compatibility and when you don't care about multiple,
  specific, or capture devices.
  """


def openAudioDevice(device optional[string]) AudioDevice:
  r"""
  """
