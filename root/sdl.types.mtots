r"""Bindings for the SDL library
"""

final WINDOW_FULLSCREEN = 0
final WINDOW_OPENGL = 0
final WINDOW_SHOWN = 0
final WINDOW_HIDDEN = 0
final WINDOW_BORDERLESS = 0
final WINDOW_RESIZABLE = 0
final WINDOW_MINIMIZED = 0
final WINDOW_MAXIMIZED = 0
final WINDOW_MOUSE_GRABBED = 0
final WINDOW_INPUT_FOCUS = 0
final WINDOW_MOUSE_FOCUS = 0
final WINDOW_FULLSCREEN_DESKTOP = 0
final WINDOW_FOREIGN = 0
final WINDOW_ALLOW_HIGHDPI = 0
final WINDOW_MOUSE_CAPTURE = 0
final WINDOW_ALWAYS_ON_TOP = 0
final WINDOW_SKIP_TASKBAR = 0
final WINDOW_UTILITY = 0
final WINDOW_TOOLTIP = 0
final WINDOW_POPUP_MENU = 0
final WINDOW_KEYBOARD_GRABBED = 0
final WINDOW_VULKAN = 0
final WINDOW_METAL = 0
final WINDOW_INPUT_GRABBED = 0
final WINDOWPOS_CENTERED = 0
final WINDOWPOS_UNDEFINED = 0
final INIT_TIMER = 0
final INIT_AUDIO = 0
final INIT_VIDEO = 0
final INIT_JOYSTICK = 0
final INIT_HAPTIC = 0
final INIT_GAMECONTROLLER = 0
final INIT_EVENTS = 0
final INIT_EVERYTHING = 0
final AUDIO_TRACK_COUNT = 0
final AUDIO_S8 = 0
final AUDIO_U8 = 0
final AUDIO_S16LSB = 0
final AUDIO_S16MSB = 0
final AUDIO_S16SYS = 0
final AUDIO_S16 = 0
final AUDIO_U16LSB = 0
final AUDIO_U16MSB = 0
final AUDIO_U16SYS = 0
final AUDIO_U16 = 0
final AUDIO_S32LSB = 0
final AUDIO_S32MSB = 0
final AUDIO_S32SYS = 0
final AUDIO_S32 = 0
final AUDIO_F32LSB = 0
final AUDIO_F32MSB = 0
final AUDIO_F32SYS = 0
final AUDIO_F32 = 0
final WAVE_FORM_SINE = 0
final WAVE_FORM_SAWTOOTH = 0
final WAVE_FORM_SQUARE = 0
final WAVE_FORM_TRIANGLE = 0
final FINGERMOTION = 0
final FINGERDOWN = 0
final FINGERUP = 0
final KEYDOWN = 0
final KEYUP = 0
final MOUSEMOTION = 0
final MOUSEBUTTONDOWN = 0
final MOUSEBUTTONUP = 0
final MOUSEWHEEL = 0
final QUIT = 0

final scancode = final{
  "UNKNOWN": 0,
  "A": 4,
  "B": 5,
  "C": 6,
  "D": 7,
  "E": 8,
  "F": 9,
  "G": 10,
  "H": 11,
  "I": 12,
  "J": 13,
  "K": 14,
  "L": 15,
  "M": 16,
  "N": 17,
  "O": 18,
  "P": 19,
  "Q": 20,
  "R": 21,
  "S": 22,
  "T": 23,
  "U": 24,
  "V": 25,
  "W": 26,
  "X": 27,
  "Y": 28,
  "Z": 29,
  "K1": 30,
  "K2": 31,
  "K3": 32,
  "K4": 33,
  "K5": 34,
  "K6": 35,
  "K7": 36,
  "K8": 37,
  "K9": 38,
  "K0": 39,
  "RETURN": 40,
  "ESCAPE": 41,
  "BACKSPACE": 42,
  "TAB": 43,
  "SPACE": 44,
  "MINUS": 45,
  "EQUALS": 46,
  "LEFTBRACKET": 47,
  "RIGHTBRACKET": 48,
  "BACKSLASH": 49,
  "NONUSHASH": 50,
  "SEMICOLON": 51,
  "APOSTROPHE": 52,
  "GRAVE": 53,
  "COMMA": 54,
  "PERIOD": 55,
  "SLASH": 56,
  "CAPSLOCK": 57,
  "F1": 58,
  "F2": 59,
  "F3": 60,
  "F4": 61,
  "F5": 62,
  "F6": 63,
  "F7": 64,
  "F8": 65,
  "F9": 66,
  "F10": 67,
  "F11": 68,
  "F12": 69,
  "PRINTSCREEN": 70,
  "SCROLLLOCK": 71,
  "PAUSE": 72,
  "INSERT": 73,
  "HOME": 74,
  "PAGEUP": 75,
  "DELETE": 76,
  "END": 77,
  "PAGEDOWN": 78,
  "RIGHT": 79,
  "LEFT": 80,
  "DOWN": 81,
  "UP": 82,
  "NUMLOCKCLEAR": 83,
  "KP_DIVIDE": 84,
  "KP_MULTIPLY": 85,
  "KP_MINUS": 86,
  "KP_PLUS": 87,
  "KP_ENTER": 88,
  "KP_1": 89,
  "KP_2": 90,
  "KP_3": 91,
  "KP_4": 92,
  "KP_5": 93,
  "KP_6": 94,
  "KP_7": 95,
  "KP_8": 96,
  "KP_9": 97,
  "KP_0": 98,
  "KP_PERIOD": 99,
  "NONUSBACKSLASH": 100,
  "APPLICATION": 101,
  "POWER": 102,
  "KP_EQUALS": 103,
  "F13": 104,
  "F14": 105,
  "F15": 106,
  "F16": 107,
  "F17": 108,
  "F18": 109,
  "F19": 110,
  "F20": 111,
  "F21": 112,
  "F22": 113,
  "F23": 114,
  "F24": 115,
  "EXECUTE": 116,
  "HELP": 117,
  "MENU": 118,
  "SELECT": 119,
  "STOP": 120,
  "AGAIN": 121,
  "UNDO": 122,
  "CUT": 123,
  "COPY": 124,
  "PASTE": 125,
  "FIND": 126,
  "MUTE": 127,
  "VOLUMEUP": 128,
  "VOLUMEDOWN": 129,
  "LOCKINGCAPSLOCK": 130,
  "LOCKINGNUMLOCK": 131,
  "LOCKINGSCROLLLOCK": 132,
  "KP_COMMA": 133,
  "KP_EQUALSAS400": 134,
  "INTERNATIONAL1": 135,
  "INTERNATIONAL2": 136,
  "INTERNATIONAL3": 137,
  "INTERNATIONAL4": 138,
  "INTERNATIONAL5": 139,
  "INTERNATIONAL6": 140,
  "INTERNATIONAL7": 141,
  "INTERNATIONAL8": 142,
  "INTERNATIONAL9": 143,
  "LANG1": 144,
  "LANG2": 145,
  "LANG3": 146,
  "LANG4": 147,
  "LANG5": 148,
  "LANG6": 149,
  "LANG7": 150,
  "LANG8": 151,
  "LANG9": 152,
  "ALTERASE": 153,
  "SYSREQ": 154,
  "CANCEL": 155,
  "CLEAR": 156,
  "PRIOR": 157,
  "RETURN2": 158,
  "SEPARATOR": 159,
  "OUT": 160,
  "OPER": 161,
  "CLEARAGAIN": 162,
  "CRSEL": 163,
  "EXSEL": 164,
  "KP_00": 176,
  "KP_000": 177,
  "THOUSANDSSEPARATOR": 178,
  "DECIMALSEPARATOR": 179,
  "CURRENCYUNIT": 180,
  "CURRENCYSUBUNIT": 181,
  "KP_LEFTPAREN": 182,
  "KP_RIGHTPAREN": 183,
  "KP_LEFTBRACE": 184,
  "KP_RIGHTBRACE": 185,
  "KP_TAB": 186,
  "KP_BACKSPACE": 187,
  "KP_A": 188,
  "KP_B": 189,
  "KP_C": 190,
  "KP_D": 191,
  "KP_E": 192,
  "KP_F": 193,
  "KP_XOR": 194,
  "KP_POWER": 195,
  "KP_PERCENT": 196,
  "KP_LESS": 197,
  "KP_GREATER": 198,
  "KP_AMPERSAND": 199,
  "KP_DBLAMPERSAND": 200,
  "KP_VERTICALBAR": 201,
  "KP_DBLVERTICALBAR": 202,
  "KP_COLON": 203,
  "KP_HASH": 204,
  "KP_SPACE": 205,
  "KP_AT": 206,
  "KP_EXCLAM": 207,
  "KP_MEMSTORE": 208,
  "KP_MEMRECALL": 209,
  "KP_MEMCLEAR": 210,
  "KP_MEMADD": 211,
  "KP_MEMSUBTRACT": 212,
  "KP_MEMMULTIPLY": 213,
  "KP_MEMDIVIDE": 214,
  "KP_PLUSMINUS": 215,
  "KP_CLEAR": 216,
  "KP_CLEARENTRY": 217,
  "KP_BINARY": 218,
  "KP_OCTAL": 219,
  "KP_DECIMAL": 220,
  "KP_HEXADECIMAL": 221,
  "LCTRL": 224,
  "LSHIFT": 225,
  "LALT": 226,
  "LGUI": 227,
  "RCTRL": 228,
  "RSHIFT": 229,
  "RALT": 230,
  "RGUI": 231,
  "MODE": 257,
  "AUDIONEXT": 258,
  "AUDIOPREV": 259,
  "AUDIOSTOP": 260,
  "AUDIOPLAY": 261,
  "AUDIOMUTE": 262,
  "MEDIASELECT": 263,
  "WWW": 264,
  "MAIL": 265,
  "CALCULATOR": 266,
  "COMPUTER": 267,
  "AC_SEARCH": 268,
  "AC_HOME": 269,
  "AC_BACK": 270,
  "AC_FORWARD": 271,
  "AC_STOP": 272,
  "AC_REFRESH": 273,
  "AC_BOOKMARKS": 274,
  "BRIGHTNESSDOWN": 275,
  "BRIGHTNESSUP": 276,
  "DISPLAYSWITCH": 277,
  "KBDILLUMTOGGLE": 278,
  "KBDILLUMDOWN": 279,
  "KBDILLUMUP": 280,
  "EJECT": 281,
  "SLEEP": 282,
  "APP1": 283,
  "APP2": 284,
  "AUDIOREWIND": 285,
  "AUDIOFASTFORWARD": 286,
  "SOFTLEFT": 287,
  "SOFTRIGHT": 288,
  "CALL": 289,
  "ENDCALL": 290,
}
final key = final{
  "UNKNOWN": 0,
  "RETURN": 0,
  "ESCAPE": 0,
  "BACKSPACE": 0,
  "TAB": 0,
  "SPACE": 0,
  "EXCLAIM": 0,
  "QUOTEDBL": 0,
  "HASH": 0,
  "PERCENT": 0,
  "DOLLAR": 0,
  "AMPERSAND": 0,
  "QUOTE": 0,
  "LEFTPAREN": 0,
  "RIGHTPAREN": 0,
  "ASTERISK": 0,
  "PLUS": 0,
  "COMMA": 0,
  "MINUS": 0,
  "PERIOD": 0,
  "SLASH": 0,
  "K0": 0,
  "K1": 0,
  "K2": 0,
  "K3": 0,
  "K4": 0,
  "K5": 0,
  "K6": 0,
  "K7": 0,
  "K8": 0,
  "K9": 0,
  "COLON": 0,
  "SEMICOLON": 0,
  "LESS": 0,
  "EQUALS": 0,
  "GREATER": 0,
  "QUESTION": 0,
  "AT": 0,
  "LEFTBRACKET": 0,
  "BACKSLASH": 0,
  "RIGHTBRACKET": 0,
  "CARET": 0,
  "UNDERSCORE": 0,
  "BACKQUOTE": 0,
  "a": 0,
  "b": 0,
  "c": 0,
  "d": 0,
  "e": 0,
  "f": 0,
  "g": 0,
  "h": 0,
  "i": 0,
  "j": 0,
  "k": 0,
  "l": 0,
  "m": 0,
  "n": 0,
  "o": 0,
  "p": 0,
  "q": 0,
  "r": 0,
  "s": 0,
  "t": 0,
  "u": 0,
  "v": 0,
  "w": 0,
  "x": 0,
  "y": 0,
  "z": 0,
  "CAPSLOCK": 0,
  "F1": 0,
  "F2": 0,
  "F3": 0,
  "F4": 0,
  "F5": 0,
  "F6": 0,
  "F7": 0,
  "F8": 0,
  "F9": 0,
  "F10": 0,
  "F11": 0,
  "F12": 0,
  "PRINTSCREEN": 0,
  "SCROLLLOCK": 0,
  "PAUSE": 0,
  "INSERT": 0,
  "HOME": 0,
  "PAGEUP": 0,
  "DELETE": 0,
  "END": 0,
  "PAGEDOWN": 0,
  "RIGHT": 0,
  "LEFT": 0,
  "DOWN": 0,
  "UP": 0,
  "NUMLOCKCLEAR": 0,
  "KP_DIVIDE": 0,
  "KP_MULTIPLY": 0,
  "KP_MINUS": 0,
  "KP_PLUS": 0,
  "KP_ENTER": 0,
  "KP_1": 0,
  "KP_2": 0,
  "KP_3": 0,
  "KP_4": 0,
  "KP_5": 0,
  "KP_6": 0,
  "KP_7": 0,
  "KP_8": 0,
  "KP_9": 0,
  "KP_0": 0,
  "KP_PERIOD": 0,
  "APPLICATION": 0,
  "POWER": 0,
  "KP_EQUALS": 0,
  "F13": 0,
  "F14": 0,
  "F15": 0,
  "F16": 0,
  "F17": 0,
  "F18": 0,
  "F19": 0,
  "F20": 0,
  "F21": 0,
  "F22": 0,
  "F23": 0,
  "F24": 0,
  "EXECUTE": 0,
  "HELP": 0,
  "MENU": 0,
  "SELECT": 0,
  "STOP": 0,
  "AGAIN": 0,
  "UNDO": 0,
  "CUT": 0,
  "COPY": 0,
  "PASTE": 0,
  "FIND": 0,
  "MUTE": 0,
  "VOLUMEUP": 0,
  "VOLUMEDOWN": 0,
  "KP_COMMA": 0,
  "KP_EQUALSAS400": 0,
  "ALTERASE": 0,
  "SYSREQ": 0,
  "CANCEL": 0,
  "CLEAR": 0,
  "PRIOR": 0,
  "RETURN2": 0,
  "SEPARATOR": 0,
  "OUT": 0,
  "OPER": 0,
  "CLEARAGAIN": 0,
  "CRSEL": 0,
  "EXSEL": 0,
  "KP_00": 0,
  "KP_000": 0,
  "THOUSANDSSEPARATOR": 0,
  "DECIMALSEPARATOR": 0,
  "CURRENCYUNIT": 0,
  "CURRENCYSUBUNIT": 0,
  "KP_LEFTPAREN": 0,
  "KP_RIGHTPAREN": 0,
  "KP_LEFTBRACE": 0,
  "KP_RIGHTBRACE": 0,
  "KP_TAB": 0,
  "KP_BACKSPACE": 0,
  "KP_A": 0,
  "KP_B": 0,
  "KP_C": 0,
  "KP_D": 0,
  "KP_E": 0,
  "KP_F": 0,
  "KP_XOR": 0,
  "KP_POWER": 0,
  "KP_PERCENT": 0,
  "KP_LESS": 0,
  "KP_GREATER": 0,
  "KP_AMPERSAND": 0,
  "KP_DBLAMPERSAND": 0,
  "KP_VERTICALBAR": 0,
  "KP_DBLVERTICALBAR": 0,
  "KP_COLON": 0,
  "KP_HASH": 0,
  "KP_SPACE": 0,
  "KP_AT": 0,
  "KP_EXCLAM": 0,
  "KP_MEMSTORE": 0,
  "KP_MEMRECALL": 0,
  "KP_MEMCLEAR": 0,
  "KP_MEMADD": 0,
  "KP_MEMSUBTRACT": 0,
  "KP_MEMMULTIPLY": 0,
  "KP_MEMDIVIDE": 0,
  "KP_PLUSMINUS": 0,
  "KP_CLEAR": 0,
  "KP_CLEARENTRY": 0,
  "KP_BINARY": 0,
  "KP_OCTAL": 0,
  "KP_DECIMAL": 0,
  "KP_HEXADECIMAL": 0,
  "LCTRL": 0,
  "LSHIFT": 0,
  "LALT": 0,
  "LGUI": 0,
  "RCTRL": 0,
  "RSHIFT": 0,
  "RALT": 0,
  "RGUI": 0,
  "MODE": 0,
  "AUDIONEXT": 0,
  "AUDIOPREV": 0,
  "AUDIOSTOP": 0,
  "AUDIOPLAY": 0,
  "AUDIOMUTE": 0,
  "MEDIASELECT": 0,
  "WWW": 0,
  "MAIL": 0,
  "CALCULATOR": 0,
  "COMPUTER": 0,
  "AC_SEARCH": 0,
  "AC_HOME": 0,
  "AC_BACK": 0,
  "AC_FORWARD": 0,
  "AC_STOP": 0,
  "AC_REFRESH": 0,
  "AC_BOOKMARKS": 0,
  "BRIGHTNESSDOWN": 0,
  "BRIGHTNESSUP": 0,
  "DISPLAYSWITCH": 0,
  "KBDILLUMTOGGLE": 0,
  "KBDILLUMDOWN": 0,
  "KBDILLUMUP": 0,
  "EJECT": 0,
  "SLEEP": 0,
  "APP1": 0,
  "APP2": 0,
  "AUDIOREWIND": 0,
  "AUDIOFASTFORWARD": 0,
  "SOFTLEFT": 0,
  "SOFTRIGHT": 0,
  "CALL": 0,
  "ENDCALL": 0,
}
final button = final{
  "LEFT": 1,
  "MIDDLE": 2,
  "RIGHT": 3,
  "X1": 4,
  "X2": 5,
}


class Event:
  "Wrapper around SDL's native Event struct"

  final type Int
  final key Int
  final repeat Bool


class Rect:
  var x Int
  var y Int
  var w Int
  var h Int

  def __init__(x, y, width, heigth):
    pass


class Point:
  var x Int
  var y Int

  def __init__(x, y):
    pass


class Window:
  "Window comments"


def createWindow(title String, x Int, y Int, width Int, height Int, flags Int) Window:
  r"""
  Create a window
  """


class Surface:
  pass


class Texture:
  pass


class Renderer:
  def present() nil:
    r"""
    Update the screen with any rendering performed since the previous call.
    SDL's rendering functions operate on a backbuffer; that is, calling a
    rendering function such as SDL_RenderDrawLine() does not directly put
    a line on the screen, but rather updates the backbuffer.
    As such, you compose your entire scene and *present* the composed
    backbuffer to the screen as a complete picture.
    Therefore, when using SDL's rendering API, one does all drawing intended
    for the frame, and then calls this function once per frame to present
    the final drawing to the user. The backbuffer should be considered
    invalidated after each present; do not assume that previous contents
    will exist between frames. You are strongly encouraged to call
    SDL_RenderClear() to initialize the backbuffer before starting each
    new frame's drawing, even if you plan to overwrite every pixel.

    Parameters:
    * renderer - the rendering context
    """

  def setDrawColor(r Int, g Int, b Int, a Int) Int:
    r"""
    ## SDL_SetRenderDrawColor
    Set the color used for drawing operations (Rect, Line and Clear).
    Set the color for drawing or filling rectangles, lines, and points,
    and for SDL_RenderClear().

    Parameters:
    * r - the red value used to draw on the rendering target
    * g - the green value used to draw on the rendering target
    * b - the blue value used to draw on the rendering target
    * a - the alpha value used to draw on the rendering target;
        usually `SDL_ALPHA_OPAQUE` (255).
        Use SDL_SetRenderDrawBlendMode to specify how the alpha channel is used

    Returns:
    0 on success or a negative error code on failure; call SDL_GetError()
    for more information.
    """

  def fillRect(rect Rect) nil:
    r"""
    ## SDL_RenderFillRect
    Fill a rectangle on the current rendering target with the drawing color.
    The current drawing color is set by SDL_SetRenderDrawColor(),
    and the color's alpha value is ignored unless blending is enabled with the
    appropriate call to SDL_SetRenderDrawBlendMode().

    Parameters:
    * rect - the SDL_Rect structure representing the rectangle to fill,
      or NULL for the entire rendering target

    Returns:
    None - this method raises on error.
    SDL_RenderFillRect will return 0 or negative error code on failure.
    This method will check and raise an error if the return value
    indicates failure.
    """

  def clear() Int:
    """
    ## SDL_RenderClear

    Clear the current rendering target with the drawing color.

    This function clears the entire rendering target, ignoring the viewport and
    the clip rectangle.

    Returns:
    None - this method raises on error.
    SDL_RenderClear will return 0 or negative error code on failure.
    This method will check and raise an error if the return value
    indicates failure.
    """


def createRenderer(window Window, index Int, flags Int) Renderer:
  r"""
  Create a 2D rendering context for a window.

  Parameters:
  * window - the window where rendering is displayed
  * index - the index of the rendering driver to initialize, or -1 to
    initialize the first one supporting the requested flags
  * flags - 0, or one or more SDL_RendererFlags OR'd together

  Returns:
  a valid rendering context or NULL if there was an error; call
  SDL_GetError() for more information.
  """


def getTicks() Float:
  r"""
  The `getTicks` function does not actually use SDL_GetTicks().
  Instead it is `SDL_GetPerformanceCounter()/SDL_GetPerformanceFrequency() * 1000`
  """


class KeyboardState:
  def __getitem__(index Int) Bool:
    pass


def getKeyboardState() KeyboardState:
  pass


def init(flags Int) nil:
  r"""
  ## SDL_Init
  Initialize the SDL library.

  SDL_Init() simply forwards to calling SDL_InitSubSystem(). Therefore, the
  two may be used interchangeably. Though for readability of your code
  SDL_InitSubSystem() might be preferred.

  The file I/O (for example: SDL_RWFromFile) and threading (SDL_CreateThread)
  subsystems are initialized by default. Message boxes
  (SDL_ShowSimpleMessageBox) also attempt to work without initializing the
  video subsystem, in hopes of being useful in showing an error dialog when
  SDL_Init fails. You must specifically initialize other subsystems if you
  use them in your application.

  Logging (such as SDL_Log) works without initialization, too.

  `flags` may be any of the following OR'd together:

  - `SDL_INIT_TIMER`: timer subsystem
  - `SDL_INIT_AUDIO`: audio subsystem
  - `SDL_INIT_VIDEO`: video subsystem; automatically initializes the events
    subsystem
  - `SDL_INIT_JOYSTICK`: joystick subsystem; automatically initializes the
    events subsystem
  - `SDL_INIT_HAPTIC`: haptic (force feedback) subsystem
  - `SDL_INIT_GAMECONTROLLER`: controller subsystem; automatically
    initializes the joystick subsystem
  - `SDL_INIT_EVENTS`: events subsystem
  - `SDL_INIT_EVERYTHING`: all of the above subsystems
  - `SDL_INIT_NOPARACHUTE`: compatibility; this flag is ignored

  Subsystem initialization is ref-counted, you must call SDL_QuitSubSystem()
  for each SDL_InitSubSystem() to correctly shutdown a subsystem manually (or
  call SDL_Quit() to force shutdown). If a subsystem is already loaded then
  this call will increase the ref-count and return.

  - \param flags subsystem initialization flags
  \returns 0 on success or a negative error code on failure; call
           SDL_GetError() for more information.

  \since This function is available since SDL 2.0.0.
  """


def quit() nil:
  r"""
  Clean up all initialized subsystems.

  You should call this function even if you have already shutdown each
  initialized subsystem with SDL_QuitSubSystem(). It is safe to call this
  function even in the case of errors in initialization.

  If you start a subsystem using a call to that subsystem's init function
  (for example SDL_VideoInit()) instead of SDL_Init() or SDL_InitSubSystem(),
  then you must use that subsystem's quit function (SDL_VideoQuit()) to shut
  it down before calling SDL_Quit(). But generally, you should not be using
  those functions directly anyhow; use SDL_Init() instead.

  You can use this function with atexit() to ensure that it is run when your
  application is shutdown, but it is not wise to do this from a library or
  other dynamically loaded code.

  \since This function is available since SDL 2.0.0.
  """

def delay(ms Int) nil:
  r"""
  NOTE: on emscripten, `emscripten_sleep` is used instead of `SDL_delay`.

  ## SDL_delay

  Wait a specified number of milliseconds before returning.

  This function waits a specified number of milliseconds before returning. It
  waits at least the specified time, but possibly longer due to OS
  scheduling.

  - \param ms the number of milliseconds to delay

  \since This function is available since SDL 2.0.0.
  """


def pollEvent(event Event) Bool:
  r"""
  ## SDL_PollEvent

  Poll for currently pending events.

  If `event` is not NULL, the next event is removed from the queue and stored
  in the SDL_Event structure pointed to by `event`. The 1 returned refers to
  this event, immediately stored in the SDL Event structure -- not an event
  to follow.

  If `event` is NULL, it simply returns 1 if there is an event in the queue,
  but will not remove it from the queue.

  As this function may implicitly call SDL_PumpEvents(), you can only call
  this function in the thread that set the video mode.

  SDL_PollEvent() is the favored way of receiving system events since it can
  be done from the main loop and does not suspend the main loop while waiting
  on an event to be posted.

  The common practice is to fully process the event queue once every frame,
  usually as a first step before updating the game's state:

  ```c
  while (game_is_still_running) {
      SDL_Event event;
      while (SDL_PollEvent(&event)) {  // poll until all events are handled!
          // decide what to do with this event.
      }

      // update game state, draw the current frame
  }
  ```

  \param event the SDL_Event structure to be filled with the next event from
               the queue, or NULL
  \returns 1 if there is a pending event or 0 if there are none available.

  \since This function is available since SDL 2.0.0.
  """


class AudioDevice:
  r"""
  Wrapper around SDL_AudioDeviceID

  ## typedef Uint32 SDL_AudioDeviceID

  SDL Audio Device IDs.

  A successful call to SDL_OpenAudio() is always device id 1, and legacy
  SDL audio APIs assume you want this device ID. SDL_OpenAudioDevice() calls
  always returns devices >= 2 on success. The legacy calls are good both
  for backwards compatibility and when you don't care about multiple,
  specific, or capture devices.
  """

  def pause(pause_on Int) nil:
    """
    Wrapper around SDL_PauseAudioDevice.

    Note that unlike if you used this API directly in C,
    there is no way to provide a callback to generate the PCM data for
    the audio. This is because mtots does not support multithreading
    and also it would probably be very inefficient for mtots to handle
    real time audio directly at the PCM level.

    Instead there are higher level API for generating audio.

    See e.g. sdl.setAudioTrack.

    ## SDL_PauseAudioDevice
    Use this function to pause and unpause audio playback on a specified
    device.

    This function pauses and unpauses the audio callback processing for a given
    device. Newly-opened audio devices start in the paused state, so you must
    call this function with **pause_on**=0 after opening the specified audio
    device to start playing sound. This allows you to safely initialize data
    for your callback function after opening the audio device. Silence will be
    written to the audio device while paused, and the audio callback is
    guaranteed to not be called. Pausing one device does not prevent other
    unpaused devices from running their callbacks.

    Pausing state does not stack; even if you pause a device several times, a
    single unpause will start the device playing again, and vice versa. This is
    different from how SDL_LockAudioDevice() works.

    If you just need to protect a few variables from race conditions vs your
    callback, you shouldn't pause the audio device, as it will lead to dropouts
    in the audio playback. Instead, you should use SDL_LockAudioDevice().

    Parameters:
    * pause_on non-zero to pause, 0 to unpause
    """


def openAudioDevice(device Optional[String]) AudioDevice:
  """
  Due to the way SDL audio works with mtots, much of SDL's documentation
  about the functions arguments are not really relevant.

  ## SDL_OpenAudioDevice
  Open a specific audio device.

  SDL_OpenAudio(), unlike this function, always acts on device ID 1. As such,
  this function will never return a 1 so as not to conflict with the legacy
  function.

  Please note that SDL 2.0 before 2.0.5 did not support recording; as such,
  this function would fail if `iscapture` was not zero. Starting with SDL
  2.0.5, recording is implemented and this value can be non-zero.
  (mtots does not currently support recording at all)

  Passing in a `device` name of NULL requests the most reasonable default
  (and is equivalent to what SDL_OpenAudio() does to choose a device). The
  `device` name is a UTF-8 string reported by SDL_GetAudioDeviceName(), but
  some drivers allow arbitrary and driver-specific strings, such as a
  hostname/IP address for a remote audio server, or a filename in the
  diskaudio driver.

  An opened audio device starts out paused, and should be enabled for playing
  by calling SDL_PauseAudioDevice(devid, 0) when you are ready for your audio
  callback function to be called. Since the audio driver may modify the
  requested size of the audio buffer, you should allocate any local mixing
  buffers after you open the audio device.

  The audio callback runs in a separate thread in most cases; you can prevent
  race conditions between your callback and other threads without fully
  pausing playback with SDL_LockAudioDevice(). For more information about the
  callback, see SDL_AudioSpec.

  Parameters:
  * device - a UTF-8 string reported by SDL_GetAudioDeviceName() or a
    driver-specific name as appropriate. NULL requests the most
    reasonable default device.

  Returns:
  None - this function raises on error.
  SDL_OpenAudioDevice will return 0 on failure.
  This function will check and raise an error if the return value
  indicates failure.
  """


def setAudioTrack(trackID Int, freq Float, amp Float, waveForm Int):
  """
  This method allows playing a fixed synth sound.
  When the audio device is unpaused, this note will be played.

  SDL audio actually does not normally work like this - normally with SDL
  you generate audio by feeding PCM values in a separate thread in an audio
  callback.

  However, mtots does not support multithreading, and even if it did,
  as a scripting language, it would probably be too slow to efficiently
  support it anyway.

  Parameters:
  * trackID - ID of the track to modify.
    Should be an integer in [0, AUDIO_TRACK_COUNT).
    AUDIO_TRACK_COUNT is currently fixed at 8.
  * freq - Frequency to synthesize with.
  * amp - Amplitude to synthesize with.
    Should be between 0 and 1. Any value outside this range will
    be clamped to [0, 1].
  * waveForm - Should be one of:
    * WAVE_FORM_SINE
    * WAVE_FORM_SAWTOOTH
    * WAVE_FORM_SQUARE
    * WAVE_FORM_TRIANGLE
  """
